# Arrays ðŸ“Š

## What This Topic Covers
Arrays are one of the fundamental data structures in computer science. This section covers:
- Static and dynamic arrays
- Array manipulation techniques
- Index-based operations
- Memory-efficient algorithms

## Common Problems & Patterns
- **Two Sum variants** - Finding pairs with target sum
- **Sliding Window** - Maximum/minimum in subarrays
- **Kadane's Algorithm** - Maximum subarray sum
- **Dutch National Flag** - Three-way partitioning
- **Merge Intervals** - Overlapping intervals problems
- **Rotate Array** - Cyclic rotations and reversals
- **Search & Sort** - Binary search, merge sort variations

## Problems Solved

| Problem | Platform | Difficulty | Summary |
|---------|----------|------------|----------|
| [3349. Adjacent Increasing Subarrays Detection I](./AdjacentIncreasingSubarrays.java) | LeetCode | Easy | Check if two adjacent subarrays of length k are strictly increasing |
| [3350. Adjacent Increasing Subarrays Detection II](./AdjacentIncreasingSubarraysII.java) | LeetCode | Medium | Find the maximum k for which two adjacent subarrays of length k are strictly increasing |
| [2598. Smallest Missing Non-negative Integer After Operations](./SmallestMissingNonNegativeIntegerAfterOperations.java) | LeetCode | Medium | Find the maximum possible MEX after adding/subtracting value from array elements |
| [2125. Number of Laser Beams in a Bank](./NumberOfLaserBeamsInABank.java) | LeetCode | Medium | Count total laser beams between security devices across non-empty rows |
| [3289. The Two Sneaky Numbers of Digitville](./TheTwoSneakyNumbersofDigitville.java) | LeetCode | Easy | Find the two numbers that appear twice in an array containing integers from 0 to n-1 |
| [1706. Where Will the Ball Fall](./WhereWillTheBallFall.java) | LeetCode | Medium | Simulate balls falling through a grid with diagonal boards, returning final column or -1 if stuck |
| [2257. Count Unguarded Cells in the Grid](./CountUnguardedCellsInTheGrid.java) | LeetCode | Medium | Count unoccupied cells not visible by any guard in the four cardinal directions, considering walls |
| [1578. Minimum Time to Make Rope Colorful](./MinimumTimeToMakeRopeColorful.java) | LeetCode | Medium | Find minimum time to remove adjacent balloons of the same color using greedy approach |
| [3542. Minimum Operations to Convert All Elements to Zero](./MinimumOperationsToConvertAllElementsToZero.java) | LeetCode | Medium | Obtain minimum number of operations required to make all elements in an array equal to 0 by certain operations |
| [1437. Check If All 1's Are at Least Length K Places Away](./CheckIfAllOnesAreAtLeastKPlacesAways.java) | LeetCode | Easy | Return **true** if every pair of '1's in the binary array is at least `k` places apart |
| [2154. Keep Multiplying Found Values by Two](./KeepMultiplyingFoundValuesByTwo.java) | LeetCode | Easy | Check what value of a number can be obtained after certain operations |
| [1930. Unique Length-3 Palindromic Subsequences](./UniqueLength3PalindromicSubsequences.java) | LeetCode | Medium | Count the **number of UNIQUE palindromic subsequences** of length 3. |
| [3190. Find Minimum Operations to Make All Elements Divisible by Three](./FindMinimumOperationsToMakeAllElementsDivisibleByThree.java) | LeetCode | Easy | Goal â†’ Make Every element divisible by 3  Return â†’ Minimum number of operations required. |
| [3512. Minimum Operations to Make Array Sum Divisible by K](./MinimumOperationsToMakeArraySumDivisibleByK.java) | LeetCode | Easy | Determine the minimum number of operations needed so that the total sum of the array becomes divisible by k. |
| [3432. Count Partitions with Even Sum Difference](./CountPartitionsWithEvenSumDifference.java) | LeetCode | Easy | We must count how many partitions produce an **even value** for: (sum(left) - sum(right)) |
| [3583. Count Special Triplets](./CountSpecialTriplets.java) | LeetCode | Medium | for 0 â‰¤ i < j < k < n ; nums[i] = nums[j] * 2 ; nums[k] = nums[j] * 2. Count all such triplets. |


## Implementation Notes
Solutions are written in **Java** with clean, optimized implementations focusing on:
- Time complexity optimization
- Space complexity considerations  
- Edge case handling
- Clean, readable code with proper commenting

---
*Part of DSA Journey: A New Dawn ðŸŒ…*
